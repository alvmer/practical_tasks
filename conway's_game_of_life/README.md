# Практикум "Игра Жизнь Конвея"

 Вашей задачей будет реализовать эмулятор Игры Жизнь на торической поверхности. Вселенной игры является поле (матрица) ![equation](https://latex.codecogs.com/png.latex?\dpi{150}&space;N\times&space;M), в которой выход за верхнюю границу перемещает клетку к нижней границе и наоборот, а выход за правый край перемещает к левому и наоборот. Другими словами, соответствующие  клетки у границ поля - соседние. В этой игре игрок выбирает лишь начальную конфигурацию поля, а далее наблюдает за его эволюцией. Для ознакомления с **правилами игры** советуем прочитать [статью Википедии](https://ru.wikipedia.org/?oldid=105800593). 

 После написания игры требуется изучить классификации фигур. Поэкспериментировать. Высказать интересные наблюдения и гипотезы.

## Техническое задание
Задание по этому практикуму представлено в двух вариантах.

#### Нормальный уровень сложности

* Игра должна иметь два режима - _режим игры_ и _режим паузы_. Изначально игра должна находиться в режиме паузы. Переключение между этими режимами должно происходить по нажатию клавиши **P**.
* Все поле игры должно выводиться в отдельном окошке, с прорисованной сеткой ![equation](https://latex.codecogs.com/png.latex?\dpi{150}&space;N\times&space;M). Живые клетки должны контрастно отличаться от мертвых по цвету (Цвет живых должен быть ярким и пестрым, а мертвых - нейтральным и фоновым. Например, черный/белый, зеленый/черный и так далее). 
* Пользователь должен иметь возможность в режиме паузы (не обязательно только в начале игры!) **по левому щелчку мыши** изменить статус любой клетки (мертвую пометить живой, живую - мертвой). Если пользователь изменил статус какой-то клетки в ходе уже запущенной эволюции, полученное состояние можно считать исходным для новой игры. Другими словами, это полученное поколение для себя нужно снова считать нулевым.
* При помощи нажатия клавиш _стрелка влево/стрелка вправо_ должна меняться скорость игры (количество кадров в секунду).
* Должна быть возможность полной очистки экрана в режиме паузы по нажатию на клавишу **C**.
* Игра (как программа) должна завершаться успешно (с нулевым кодом возврата) в момент закрытия пользователем игрового окошка (нажатия на крестик).
* Требуется иметь friendly интерфейс, то есть подсказки о горячих клавишах должны быть на экране (и быть актуальными!). Например, в режиме паузы можно предложить игроку нажать *P* для того, чтобы продолжить игру, а в режиме игры можно предложить поставить игру на паузу.

#### Уровень сложности HARD

* В самом верху экрана по середине (!) творческим шрифтом (!) должно быть написано ***Game of Life***.
* Должна выводиться информация о номере поколения (и быть актуальной!).
* Игра должна определять момент своего окончания и выводить этот статус (состояние стабилизировалось, все клетки умерли, найден цикл) на экран. При этом нумерация поколений должна прекратиться. Для первых двух состояний игра автоматически должна становиться на паузу, а при циклическом завершении должна продолжать работать (очень красиво наблюдать циклы).

## Идеи реализации

Чтобы написать столь серьезный проект, его нужно логически точно разбить на две части - функции, касающиеся эмуляции самой игры, и функции, заботящиеся об ее отрисовке в окошечке и общении с пользователем. 

### Backend ядро игры

Очевидно, что текущее состояние игры (поколение) удобно хранить в виде `bool` матрицы. Тогда смена состояния равносильна присваиванию `m[i][j] = !m[i][j]`. Для смены поколений можно применять простой алгоритм. Так как для всех клеток условия игры применяются единовременно, нужно создать еще одну матрицу нового поколения и отмечать живые клетки в ней, проходясь при этом по матрице старого поколения. После нужно просто присвоить старому поколению новое.

Для эмуляции игры на торе нужно лишь вычислять координаты по измерениям `i` и `j` по модулю `N` и `M` соответственно. При этом важно помнить, что по модулю могут браться отрицательные числа! Напрмиер, -1 mod N = N - 1.

### Frontend окно и графика

Для реализации графики и всех требований можно использовать либо ***Qt***, либо ***SFML***. Далее руководство будет предложено для SFML. Это такая библиотека, которую нужно сначала установить, затем в программе написать 
```c++
#include <SFML/Graphics.hpp>
```
Если программа с таким инклудом компилируется, вы уже на полпути к победе! :) Для работы с графикой нужно создавать специальные `sf::` объекты, устанавливать им разные опции (содержание, шрифт, размер, позиция по координатам на экране и т.д.) при помощи их методов, а затем рисовать их в окне. Центральным объектом является само окно
```c++
 sf::RenderWindow window(sf::VideoMode(kFieldWidth * kCellSize, kFieldHeight * kCellSize), "Game of Life");
 ```
Затем, добавить на это окно можно любой специальный объект _object_, который вы уже настроили, при помощи команды `window.draw(object)`. 

Анимация в игре достигается за счет полной отрисовки окна заново в новом поколении клеток (или в новом режиме паузы, например). Для этого, пока открыто окно, бесконечный `while(window.isOpen()) ...` должен этим заниматься. Чтобы мы вообще могли уследить за тем, что происходит, нужна задержка **delay**, длительность которой и определяет текущую скорость игры. После каждого кадра мы просто ждем **delay** миллисекунд. 
```c++
 sf::sleep(sf::milliseconds(delay));
```  
Для системного взаимодействия с пользователем (умения перехватывать нажатия клавиш и т.д.) пригодится такой объект, как `sf::Event`. Каждый раз, когда пользователь что-то нажал, куда-то кликнул, говорят, что произошел некоторый _ивент_ (событие). Это событие SFML сохраняет у себя и любезно может положить в объект `sf::Event`. Грубо говоря, когда мы дошли до обработки событий, их могло накопиться уже какое-то количество, и нам их все нужно обработать. Для этого нужно написать 
```c++
sf::Event event;
while (window.pollEvent(event)) {
    // обработка текущего event: разбор случаев
}
```
Этот `while` поочередно при помощи `window.pollEvent` достает события, которые накопились и связаны с нашим окошком `window`, пока они есть, и кладет нам в переменную `event`. В такой конструкции мы всегда обработаем все и ничего не упустим. Далее нужно узнать, что за событие произвел пользователь: нажал на **P**, или на **C**, или вообще кликнул **левой мышкой**. Для этого удобно использовать оператор `switch`, либо написать простой каскад `if-else`  по парамеру `event.type`. Например,
```c++
if (event.type == sf::Event::KeyPressed) {
    if (event.key.code == sf::Keyboard::P) {
        // обработка нажатия клавиши P
    }
}
```
Такой код разбирает случай нажатия пользователем клавиши **P**.

#### Полезные материалы SFML для этого практикума

1. Объект [sf::RenderWindow window](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderWindow.php)
  * Метод [window.isOpen()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php#ae873503db7d48157bb9cbf6129562bce)
  * Метод [window.pollEvent()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php#a338e996585faf82e93069858e3b531b7)
  * Метод [window.draw()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTarget.php#a12417a3bcc245c41d957b29583556f39)
  * Метод [window.display()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php#adabf839cb103ac96cfc82f781638772a)
  * Метод [window.clear()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1RenderTarget.php#a6bb6f0ba348f2b1e2f46114aeaf60f26)
  * Метод [window.close()](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Window.php#a99d1e030387b0c26f5995670504fe7b5)
2. Объект [sf::Event event](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Event.php)
  * Разбор типа событий [sf::Event::EventType
](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Event.php#af41fa9ed45c02449030699f671331d4a). Ключевые `sf::Event::Closed`, `sf::Event::KeyPressed`, `sf::Event::MouseButtonPressed`.
3. Шрифт [sf::Font](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Font.php)
4. Текст [sf::Text](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Text.php)
3. Цвет [sf::Color](https://www.sfml-dev.org/documentation/2.5.1/classsf_1_1Color.php). Полезные `sf::Color::Black`, `sf::Color::White`, `sf::Color::Green` и т.д. Можно использовать палитру RGB для сетки, например, серый цвет `sf::Color(153, 153, 153)`.
 
## Литература

1.[Базовая статья Википедии](https://ru.wikipedia.org/?oldid=105800593).
2.[Научный обзор Гарднера (о фигурах)](http://life.written.ru/game_of_life_review_by_gardner).
3.[Ссылка для установки SFML а также их главный сайт](https://www.sfml-dev.org/download.php).


